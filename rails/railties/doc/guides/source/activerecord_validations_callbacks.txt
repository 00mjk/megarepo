Active Record Validations and Callbacks
=======================================

This guide teaches you how to work with the lifecycle of your Active Record objects. More precisely, you will learn how to validate the state of your objects before they go into the database and also how to teach them to perform custom operations at certain points of their lifecycles.

After reading this guide and trying out the presented concepts, we hope that you'll be able to:

* Correctly use all the built-in Active Record validation helpers
* Create your own custom validation methods
* Work with the error messages generated by the validation proccess
* Register callback methods that will execute custom operations during your objects lifecycle, for example before/after they are saved.
* Create special classes that encapsulate common behaviour for your callbacks
* Create Observers - classes with callback methods specific for each of your models, keeping the callback code outside your models' declarations.

== Motivations to validate your Active Record objects

The main reason for validating your objects before they get into the database is to ensure that only valid data is recorded. It's important to be sure that an email address column only contains valid email addresses, or that the customer's name column will never be empty. Constraints like that keep your database organized and helps your application to work properly. 

There are several ways to validate the data that goes to the database, like using database native constraints, implementing validations only at the client side or implementing them directly into your models. Each one has pros and cons:

* Using database constraints and/or stored procedures makes the validation mechanisms database-dependent and may turn your application into a hard to test and mantain beast. However, if your database is used by other applications, it may be a good idea to use some constraints also at the database level.
* Implementing validations only at the client side can be problematic, specially with web-based applications. Usually this kind of validation is done using javascript, which may be turned off in the user's browser, leading to invalid data getting inside your database. However, if combined with server side validation, client side validation may be useful, since the user can have a faster feedback from the application when trying to save invalid data.
* Using validation directly into your Active Record classes ensures that only valid data gets recorded, while still keeping the validation code in the right place, avoiding breaking the MVC pattern. Since the validation happens on the server side, the user cannot disable it, so it's also safer. It may be a hard and tedious work to implement some of the logic involved in your models' validations, but fear not: Active Record gives you the hability to easily create validations, using several built-in helpers while still allowing you to create your own validation methods.

== How it works

=== When does validation happens?

There are two kinds of Active Record objects: those that correspond to a row inside your database and those who do not. When you create a fresh object, using the +new+ method, that object does not belong to the database yet. Once you call +save+ upon that object it'll be recorded to it's table. Active Record uses the +new_record?+ instance method to discover if an object is already in the database or not. Consider the following simple and very creative Active Record class:

[source, ruby]
------------------------------------------------------------------
class Person < ActiveRecord::Base
end
------------------------------------------------------------------

We can see how it works by looking at the following script/console output:

------------------------------------------------------------------
>> p = Person.new(:name => "John Doe", :birthdate => Date.parse("09/03/1979"))
=> #<Person id: nil, name: "John Doe", birthdate: "1979-09-03", created_at: nil, updated_at: nil>
>> p.new_record?
=> true
>> p.save
=> true
>> p.new_record?
=> false
------------------------------------------------------------------

Saving new records means sending an SQL insert operation to the database, while saving existing records (by calling either +save+, +update_attribute+ or +update_attributes+) will result in a SQL update operation. Active Record will use this facts to perform validations upon your objects, avoiding then to be recorded to the database if their inner state is invalid in some way. You can specify validations that will be beformed every time a object is saved, just when you're creating a new record or when you're updating an existing one.

=== The meaning of 'valid'

For verifying if an object is valid, Active Record uses the +valid?+ method, which basically looks inside the object to see if it has any validation errors. These errors live in a collection that can be accessed through the +errors+ instance method. The proccess is really simple: If the +errors+ method returns an empty collection, the object is valid and can be saved. Each time a validation fails, an error message is added to the +errors+ collection.

== The declarative validation helpers

Active Record offers many pre-defined validation helpers that you can use directly inside your class definitions. These helpers create validations rules that are commonly used in most of the applications that you'll write, so you don't need to recreate it everytime, avoiding code duplication, keeping everything organized and boosting your productivity. Everytime a validation fails, an error message is added to the object's +errors+ collection, this message being associated with the field being validated. 

Each helper accepts an arbitrary number of attributes, received as symbols, so with a single line of code you can add the same kind of validation to several attributes.

All these helpers accept the +:on+ and +:message+ options, which define when the validation should be applied and what message should be added to the +errors+ collection when it fails, respectively. The +:on+ option takes one the values +:save+ (it's the default), +:create+  or +:update+. There is a default error message for each one of the validation helpers. These messages are used when the +:message+ option isn't used. Let's take a look at each one of the available helpers, listed in alphabetic order.

=== The +validates_acceptance_of+ helper

Validates that a checkbox has been checked for agreement purposes. It's normally used when the user needs to agree with your application's terms of service, confirm reading some clauses or any similar concept. This validation is very specific to web applications and actually this 'acceptance' does not need to be recorded anywhere in your database (if you don't have a field for it, the helper will just create a virtual attribute).

[source, ruby]
------------------------------------------------------------------
class Person < ActiveRecord::Base
  validates_acceptance_of :terms_of_service
end
------------------------------------------------------------------

The default error message for +validates_acceptance_of+ is "_must be accepted_"

+validates_acceptance_of+ can receive an +:accept+ option, which determines the value that will be considered acceptance. It defaults to "1", but you can change it.

[source, ruby]
------------------------------------------------------------------
class Person < ActiveRecord::Base
  validates_acceptance_of :terms_of_service, :accept => 'yes'
end
------------------------------------------------------------------


=== The +validates_associated+ helper

You should use this helper when your model has associations with other models and they also need to be validated. When you try to save your object, +valid?+ will be called upon each one of the associated objects.

[source, ruby]     
------------------------------------------------------------------
class Library < ActiveRecord::Base
  has_many :books
  validates_associated :books
end
------------------------------------------------------------------

This validation will work with all the association types.

CAUTION: Pay attention not to use +validates_associated+ on both ends of your associations, because this will lead to several recursive calls and blow up the method calls' stack.

The default error message for +validates_associated+ is "_is invalid_". Note that the errors for each failed validation in the associated objects will be set there and not in this model.

=== The +validates_confirmation_of+ helper

You should use this helper when you have two text fields that should receive exactly the same content, like when you want to confirm an email address or password. This validation creates a virtual attribute, using the name of the field that has to be confirmed with '_confirmation' appended.

[source, ruby]
------------------------------------------------------------------
class Person < ActiveRecord::Base
  validates_confirmation_of :email
end
------------------------------------------------------------------

In your view template you could use something like
------------------------------------------------------------------
<%= text_field :person, :email %>
<%= text_field :person, :email_confirmation %>
------------------------------------------------------------------

NOTE: This check is performed only if +email_confirmation+ is not nil, and by default only on save. To require confirmation, make sure to add a presence check for the confirmation attribute (we'll take a look at +validates_presence_of+ later on this guide):

[source, ruby]
------------------------------------------------------------------
class Person < ActiveRecord::Base
  validates_confirmation_of :email
  validates_presence_of :email_confirmation
end
------------------------------------------------------------------

The default error message for +validates_confirmation_of+ is "_doesn't match confirmation_"

=== The +validates_each+ helper

This helper validates attributes against a block. It doesn't have a predefined validation function. You should create one using a block, and every attribute passed to +validates_each+ will be tested against it. In the following example, we don't want names and surnames to begin with lower case.

[source, ruby]
------------------------------------------------------------------
class Person < ActiveRecord::Base
  validates_each :name, :surname do |model, attr, value|
    model.errors.add(attr, 'Must start with upper case') if value =~ /^[a-z]/
  end
end
------------------------------------------------------------------

The block receives the model, the attribute's name and the attribute's value. If your validation fails, you can add an error message to the model, therefore making it invalid.

=== The +validates_exclusion_of+ helper

This helper validates that the attributes' values are not included in a given set. In fact, this set can be any enumerable object.

[source, ruby]
------------------------------------------------------------------
class MovieFile < ActiveRecord::Base
  validates_exclusion_of :format, :in => %w(mov avi), :message => "Extension %s is not allowed"
end
------------------------------------------------------------------

The +validates_exclusion_of+ helper has an option +:in+ that receives the set of values that will not be accepted for the validated attributes. The +:in+ option has an alias called +:within+  that you can use for the same purpose, if you'd like to. In the previous example we used the +:message+ option to show how we can personalize it with the current attribute's value, through the +%s+ format mask.

The default error message for +validates_exclusion_of+  is "_is not included in the list_".

=== The +validates_format_of+ helper

This helper validates the attributes's values by testing if they match a given pattern. This pattern must be specified using a Ruby regular expression, which must be passed through the +:with+ option.

[source, ruby]
------------------------------------------------------------------
class Product < ActiveRecord::Base
  validates_format_of :description, :with => /^[a-zA-Z]+$/, :message => "Only letters allowed"
end
------------------------------------------------------------------

The default error message for +validates_format_of+ is "_is invalid_".

=== The +validates_inclusion_of+ helper

=== The +validates_length_of+ helper

=== The +validates_numericallity_of+ helper

=== The +validates_presence_of+ helper

=== The +validates_size_of+ helper

=== The validates_uniqueness_of+ helper

== Common validation options



== Credits



== Changelog

http://rails.lighthouseapp.com/projects/16213/tickets/26-active-record-validations-and-callbacks
