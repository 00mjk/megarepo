h2. Action View Overview

In this guide you will learn:

* What Action View is, and how to use it with Rails
* How to use Action View outside of Rails
* How best to use templates, partials, and layouts
* What helpers are provided by Action View, and how to make your own
* How to use localized views

endprologue.

h3. What is Action View?

Action View and Action Controller are the two major components of Action Pack. In Rails, web requests are handled by Action Pack, which splits the work into a controller part (performing the logic) and a view part (rendering a template). Typically, Action Controller will be concerned with communicating with the database and performing CRUD actions where necessary. Action View is then responsible for compiling the response. 

Action View templates are written using embedded Ruby in tags mingled with HTML. To avoid cluttering the templates with boilerplate code, a number of helper classes provide common behavior for forms, dates, and strings. It's also easy to add new helpers to your application as it evolves. 

Note: Some features of Action View are tied to Active Record, but that doesn't mean that Action View depends on Active Record. Action View is an independent package that can be used with any sort of backend.

h3. Using Action View with Rails

TODO...

h3. Using Action View outside of Rails

Action View works well with Action Record, but it can also be used with other Ruby tools. We can demonstrate this by creating a small "Rack":http://rack.rubyforge.org/ application that includes Action View functionality. This may be useful, for example, if you'd like access to Action View's helpers in a Rack application. 

Let's start by ensuring that you have the Action Pack and Rack gems installed:

<shell>
gem install actionpack
gem install rack
</shell>

Now we'll create a simple "Hello World" application that uses the +titleize+ method provided by Action View.

*hello_world.rb:*

<ruby>
require 'rubygems'
require 'action_view'
require 'rack'

def hello_world(env)
  [200, {"Content-Type" => "text/html"}, "hello world".titleize]
end

Rack::Handler::Mongrel.run method(:hello_world), :Port => 4567
</ruby>

We can see this all come together by starting up the application and then visiting +http://localhost:4567/+

<shell>
ruby hello_world.rb
</shell>

TODO needs a screenshot? I have one - not sure where to put it. 

Notice how 'hello world' has been converted into 'Hello World' by the +titleize+ helper method. 

Action View can also be used with "Sinatra":http://www.sinatrarb.com/ in the same way. 

Let's start by ensuring that you have the Action Pack and Sinatra gems installed:

<shell>
gem install actionpack
gem install sinatra
</shell>

Now we'll create the same "Hello World" application in Sinatra.

*hello_world.rb:*

<ruby>
require 'rubygems'
require 'action_view'
require 'sinatra'

get '/' do
  erb 'hello world'.titleize
end
</ruby>

Then, we can run the application:

<shell>
ruby hello_world.rb
</shell>

Once the application is running, you can see Sinatra and Action View working together by visiting +http://localhost:4567/+

TODO needs a screenshot? I have one - not sure where to put it. 

h3. Templates, Partials and Layouts

TODO...

h3. Using Templates, Partials and Layouts in "The Rails Way"

TODO...

h3. Partial Layouts

Partials can have their own layouts applied to them. These layouts are different than the ones that are specified globally for the entire action, but they work in a similar fashion.

Let's say we're displaying a post on a page where it should be wrapped in a +div+ for display purposes. First, we'll create a new +Post+:

<ruby>
Post.create(:body => 'Partial Layouts are cool!')
</ruby>

In the +show+ template, we'll render the +post+ partial wrapped in the +box+ layout:

*posts/show.html.erb*

<ruby>
<%= render :partial => 'post', :layout => 'box', :locals => {:post => @post} %>
</ruby>

The +box+ layout simply wraps the +post+ partial in a +div+:

*posts/_box.html.erb*

<ruby>
<div class='box'>
  <%= yield %>
</div>
</ruby>

The +post+ partial wraps the post's +body+ in a +div+ with the +id+ of the post using the +div_for+ helper:

*posts/_post.html.erb*

<ruby>
<% div_for(post) do %>
  <p><%= post.body %></p>
<% end %>
</ruby>

This example would output the following:

<ruby>
<div class='box'>
  <div id='post_1'>
    <p>Partial Layouts are cool!</p>
  </div>
</div>
</ruby>

Note that the partial layout has access to the local +post+ variable that was passed into the +render+ call. However, unlike application-wide layouts, partial layouts still have the underscore prefix.

You can also render a block of code within a partial layout instead of calling +yield+. For example, if we didn't have the +post+ partial, we could do this instead:

*posts/show.html.erb*

<ruby>
<% render(:layout => 'box', :locals => {:post => @post}) do %>
  <% div_for(post) do %>
    <p><%= post.body %></p>
  <% end %>
<% end %>
</ruby>

If we're using the same +box+ partial from above, his would produce the same output as the previous example.

h3. View Paths

TODO...

h3. Overview of all the helpers provided by AV

TODO...

h3. Localized Views

Action View has the ability render different templates depending on the current locale.

For example, suppose you have a Posts controller with a show action. By default, calling this action will render +app/views/posts/show.html.erb+. But if you set +I18n.locale = :de+, then +app/views/posts/show.de.html.erb+ will be rendered instead. If the localized template isn't present, the undecorated version will be used. This means you're not required to provide localized views for all cases, but they will be preferred and used if available. 

You can use the same technique to localize the rescue files in your public directory. For example, setting +I18n.locale = :de+ and creating +public/500.de.html+ and +public/404.de.html+ would allow you to have localized rescue pages.

Since Rails doesn't restrict the symbols that you use to set I18n.locale, you can leverage this system to display different content depending on anything you like. For example, suppose you have some "expert" users that should see different pages from "normal" users. You could add the following to +app/controllers/application.rb+: 

<ruby>
before_filter :set_expert_locale

def set_expert_locale
  I18n.locale = :expert if current_user.expert?
end
</ruby>

Then you could create special views like +app/views/posts/show.expert.html.erb+ that would only be displayed to expert users.

You can read more about the Rails Internationalization (I18n) API "here":i18n.html. 

h3. Changelog

"Lighthouse Ticket":http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/71

* September 3, 2009: Continuing work by Trevor Turk, leveraging the "Action Pack docs":http://ap.rubyonrails.org/ and "What's new in Edge Rails":http://ryandaigle.com/articles/2007/8/3/what-s-new-in-edge-rails-partials-get-layouts
* April 5, 2009: Starting work by Trevor Turk, leveraging Mike Gunderloy's docs
